<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitwarden De-duplicator | Secure Vault Optimization</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Outfit:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --primary: #175ddc;
            --primary-hover: #1552c6;
            --primary-light: #528bff;
            --bg: #171b21;
            --surface: #171b21;
            --surface-alt: #1f242c;
            --surface-hover: #242933;
            --header-bg: #171b21;
            --sidebar-bg: #101419;
            --sidebar-active: #1c222b;
            --border: #2e333d;
            --text: #ffffff;
            --text-heading: #ffffff;
            --text-muted: #9aa0a6;
            --danger: #e24e4d;
            --danger-hover: #c93b3b;
            --success: #28c76f;
            --accent: #175ddc;
            --sidebar-w: 260px;
            /* Optimization: Animate only colors, avoid layout/transform properties */
            --transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
        }

        body.light-mode {
            --bg: #ffffff;
            --surface: #ffffff;
            --surface-alt: #f8f9fa;
            --surface-hover: #f3f4f6;
            --header-bg: #ffffff;
            --sidebar-bg: #f8f9fa;
            --sidebar-active: #e9ecef;
            --border: #dee2e6;
            --text: #333333;
            --text-heading: #171b21;
            --text-muted: #6c757d;
            --primary: #175ddc;
            --primary-hover: #1552c6;
            --danger: #dc3545;
        }

        body.light-mode .upload-overlay {
            background-color: #f8fafc;
        }

        body.light-mode .nav-item:hover {
            background: var(--surface-hover);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Optimization: Scope outline color to interactive elements only */
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible,
        button:focus-visible,
        a:focus-visible,
        [tabindex]:focus-visible {
            outline-color: var(--primary);
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            line-height: 1.5;
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: 'Outfit', sans-serif;
            color: var(--text-heading);
            font-weight: 600;
        }

        /* Layout Structure */
        .app-shell {
            display: grid;
            grid-template-columns: var(--sidebar-w) 1fr;
            grid-template-rows: 70px 1fr;
            height: 100vh;
            width: 100vw;
        }

        /* Top Navbar */
        .navbar {
            grid-column: 1 / -1;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            z-index: 100;
            box-shadow: 0 4px 20px 0 rgba(0, 0, 0, .05);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .brand-logo {
            font-size: 1.5rem;
        }

        .brand-text {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-heading);
            letter-spacing: -0.5px;
        }

        .nav-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        /* Sidebar Navigation */
        .sidebar {
            background: var(--sidebar-bg);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-search {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .search-input {
            width: 100%;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            font-size: 0.85rem;
            transition: var(--transition);
        }

        .search-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .sidebar-nav {
            flex: 1;
            overflow-y: auto;
            padding: 0.75rem;
        }

        .nav-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.6rem 0.75rem;
            cursor: pointer;
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.9rem;
            transition: var(--transition);
            margin-bottom: 2px;
        }

        .nav-item:hover {
            background: var(--surface-hover);
            color: var(--text);
        }

        .nav-item.active {
            background: rgba(23, 93, 220, 0.1);
            /* Low opacity blue tint */
            color: var(--primary-light);
            font-weight: 600;
        }

        .nav-item .count {
            font-size: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: 400;
        }

        /* Main Content Viewport */
        .viewport {
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        /* Fixed Toolbar */
        .toolbar {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* Center the title and the action block */
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            min-height: 80px;
        }

        .action-group {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
        }

        /* Select Bar (Contextual) */
        .selection-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--surface);
            color: var(--text-heading);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            transform: translateY(-100%);
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 90;
            border-bottom: 2px solid var(--primary);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .selection-bar.visible {
            transform: translateY(0);
        }

        .content-shifter {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
            transition: transform 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }

        .content-shifter.shifted {
            transform: translateY(60px);
        }

        /* Table Container */
        .table-wrap {
            flex: 1;
            overflow: auto;
            margin: 1rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: var(--surface);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
            /* Prevents columns from shifting */
        }

        thead th {
            background: var(--header-bg);
            color: var(--text-heading);
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            padding: 1rem;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 80;
            border-bottom: 2px solid var(--border);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        th:nth-child(1) {
            width: 50px;
        }

        th:nth-child(2) {
            width: 45%;
        }

        /* Name column */
        th:nth-child(3) {
            width: 30%;
        }

        /* Password column */
        th:nth-child(4),
        .action-cell {
            width: 120px;
            text-align: center;
        }

        tbody tr {
            border-bottom: 1px solid var(--border);
            transition: var(--transition);
            cursor: pointer;
        }

        tbody tr:hover {
            background: var(--surface-hover);
        }

        tbody tr.focused {
            background: var(--surface-hover);
            box-shadow: inset 4px 0 0 0 var(--primary) !important;
        }

        tbody tr.selected {
            background: rgba(59, 130, 246, 0.08);
        }

        tbody tr.deleted {
            opacity: 0.6;
        }

        tbody tr.deleted .reason-badge {
            opacity: 1;
            background: rgba(226, 78, 77, 0.2);
            color: #ff8e8d;
            /* Brighter red for dark mode */
        }

        td {
            padding: 1rem;
            vertical-align: middle;
            text-align: left;
        }

        .checkbox-cell {
            width: 50px;
            text-align: center;
        }

        /* Data Presentation */
        .field-box {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .field-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 4px;
            /* More space for the label */
        }

        .field-value {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-heading);
        }

        /* Truncation & Popover System */
        .truncator {
            position: relative;
            max-width: 100%;
        }

        .truncator-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: block;
            cursor: help;
        }

        .truncator-popover {
            position: absolute;
            top: -8px;
            left: -8px;
            padding: 8px;
            background: var(--surface);
            border: 1px solid var(--border);
            opacity: 0;
            pointer-events: none;
            z-index: 200;
            width: max-content;
            min-width: 100%;
            max-width: 400px;
            white-space: normal;
            word-break: break-all;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            transition: opacity 0.1s ease;
            color: var(--text-heading);
            font-size: inherit;
        }

        .truncator.can-truncate:hover .truncator-popover {
            opacity: 1;
            pointer-events: auto;
        }

        .field-sub {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .password-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            position: relative;
        }

        .password-val {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            letter-spacing: 1px;
            color: var(--primary-light);
            display: block;
        }


        /* Buttons & Inputs */
        .btn {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            /* Squared look */
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            border: none;
            transition: var(--transition);
        }

        .btn-primary {
            background: var(--primary);
            color: #fff;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        .btn-danger {
            background: var(--danger);
            color: #fff;
        }

        .btn-danger:hover {
            background: var(--danger-hover);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text);
        }

        .btn-outline:hover {
            background: var(--surface-hover);
            border-color: var(--text-muted);
        }

        .btn:disabled {
            cursor: not-allowed !important;
            opacity: 0.5 !important;
        }

        .select-sm {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 2rem 0.5rem 0.75rem;
            border-radius: 8px;
            font-size: 0.85rem;
            appearance: none;
            cursor: pointer;
        }

        /* Checkbox Styling */
        .checkbox-cell {
            width: 50px;
            text-align: center;
        }

        .custom-checkbox {
            width: 1.2rem;
            height: 1.2rem;
            appearance: none;
            border: 2px solid var(--border);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: var(--transition);
            background: var(--bg);
        }

        .custom-checkbox:checked,
        .custom-checkbox.checked {
            background: var(--primary);
            border-color: var(--primary);
        }

        .custom-checkbox:checked::after,
        .custom-checkbox.checked::after {
            content: '‚úì';
            position: absolute;
            color: #fff;
            font-size: 0.8rem;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        /* Toggle Switch */
        .toggle-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text);
            user-select: none;
            height: 38px;
            /* Match height of select/buttons */
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 20px;
            transition: var(--transition);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: var(--text-muted);
            border-radius: 50%;
            transition: var(--transition);
        }

        input:checked+.toggle-switch {
            background: var(--danger);
            border-color: var(--danger);
        }

        input:checked+.toggle-switch::after {
            transform: translateX(16px);
            background: #fff;
        }

        /* Review Mode Reason Badge */
        .reason-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            background: rgba(226, 78, 77, 0.2);
            color: #ff8e8d;
            font-size: 0.8rem;
            font-weight: 700;
            border: 1px solid rgba(226, 78, 77, 0.4);
            white-space: nowrap;
            letter-spacing: 0.3px;
        }

        /* Upload States */
        .upload-overlay {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(20px);
        }

        .drop-zone {
            padding: 4rem;
            border: 2px dashed var(--border);
            border-radius: 2rem;
            background: var(--surface);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .drop-zone:hover {
            border-color: var(--primary);
            transform: translateY(-4px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .hidden {
            display: none !important;
        }

        /* Dashboard Styles */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
            padding: 1.5rem;
        }

        .stat-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            transition: var(--transition);
        }

        .stat-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-title {
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: 600;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-heading);
            font-family: 'Outfit', sans-serif;
        }

        .health-grade {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: 800;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
        }

        .grade-a {
            background: linear-gradient(135deg, #28c76f, #48da89);
        }

        .grade-b {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }

        .grade-c {
            background: linear-gradient(135deg, #f1c40f, #f39c12);
        }

        .grade-f {
            background: linear-gradient(135deg, #ea5455, #ff9f43);
        }

        .issue-list {
            margin-top: 0.5rem;
        }

        .issue-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .indicator.red {
            background: var(--danger);
        }

        .indicator.yellow {
            background: #f1c40f;
        }

        .indicator.green {
            background: var(--success);
        }

        /* Accessibility: Skip to content */
        .skip-link {
            position: absolute;
            top: -100px;
            left: 0;
            background: var(--primary);
            color: #fff;
            padding: 1rem;
            z-index: 2000;
            transition: top 0.2s;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Loading States */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(10, 15, 29, 0.7);
            backdrop-filter: blur(8px);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .loader-card {
            background: var(--surface);
            padding: 2rem 3.5rem;
            border-radius: 20px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <div id="uploadOverlay" class="upload-overlay">
        <div class="drop-zone" onclick="document.getElementById('fileInput').click()">
            <div>
                <h1 style="margin-bottom: 0.5rem;">Import Bitwarden Export</h1>
                <p style="color: var(--text-muted);">Drop your .json file here to start cleaning.</p>
            </div>
            <button class="btn btn-primary">Choose File</button>
            <input type="file" id="fileInput" accept=".json" class="hidden">
        </div>
    </div>

    <div class="app-shell hidden" id="app">
        <nav class="navbar" role="navigation">
            <div class="brand">
                <h1 class="brand-text">Bitwarden <span style="font-weight: 300; opacity: 0.7;">Deduplicator</span></h1>
            </div>
            <div class="nav-actions">
                <div id="statSummary" style="font-size: 0.85rem; color: var(--text-muted); display: flex; gap: 1.5rem;">
                    <span>Total: <strong id="totalCount" style="color: var(--text-heading)">0</strong></span>
                    <span>Removed: <strong id="removedCount" style="color: var(--danger)">0</strong></span>
                </div>
                <button class="btn btn-outline" onclick="toggleTheme()" id="themeToggle"
                    aria-label="Toggle between dark and light mode" title="Toggle between dark and light mode">
                    <span id="themeToggleIcon">üåô</span>
                    <span id="themeToggleText">Dark Mode</span>
                </button>
                <button class="btn btn-outline" onclick="undoLastAction()" id="undoBtn" disabled
                    title="Undo last delete">
                    <span>‚Ü©Ô∏è</span>
                    <span>Undo</span>
                </button>
                <button class="btn btn-outline" onclick="resetApp()" title="Clear all and start over">
                    <span>üîÑ</span>
                    <span>Reset</span>
                </button>
                <button class="btn btn-primary" onclick="downloadJSON()">Export cleaned</button>
            </div>
        </nav>

        <aside class="sidebar">
            <div class="sidebar-search">
                <input type="text" class="search-input" placeholder="Search domains..." id="sidebarSearch"
                    oninput="renderSidebar()">
            </div>
            <nav class="sidebar-nav" id="sidebarList" aria-label="Groups by Domain">
                <!-- Groups generate here -->
            </nav>
        </aside>

        <main class="viewport" id="main-content">
            <div class="selection-bar" id="selectionBar">
                <span id="selectionText" style="font-weight: 600;">0 items selected</span>
                <div class="action-group">
                    <button id="selectionDeleteBtn" class="btn btn-primary" onclick="bulkAction(true)">
                        Delete selection
                    </button>
                    <button id="selectionRestoreBtn" class="btn btn-outline" onclick="bulkAction(false)">
                        Restore selection
                    </button>
                    <button class="btn btn-outline" onclick="clearSelection()">
                        Cancel
                    </button>
                </div>
            </div>

            <div class="content-shifter" id="contentShifter">
                <div class="toolbar">
                    <div class="action-group">
                        <h2 id="tabTitle" style="font-size: 1.5rem;">Everything</h2>
                    </div>
                    <div class="action-group">
                        <div class="field-box">
                            <span class="field-label">Delete strategy</span>
                            <select id="dedupeMode" class="select-sm">
                                <option value="domain_all">Exact Match (Domain, User, Pass)</option>
                                <option value="url_all">Exact Match (Full URL, User, Pass)</option>
                                <option value="name_all">Exact Match (Site Name, User, Pass)</option>
                                <option value="user_pass">Global Match (User & Pass only)</option>
                                <option value="user">Uniform Match (Username only)</option>
                                <option value="incomplete">Scrub: Empty User OR Pass</option>
                                <option value="incomplete_both">Scrub: Empty User AND Pass</option>
                            </select>
                        </div>
                        <label class="toggle-label">
                            <input type="checkbox" onchange="toggleReviewMode(this)" class="hidden">
                            <div class="toggle-switch"></div>
                            <span>Review Deleted</span>
                        </label>
                        <button class="btn btn-outline" onclick="toggleBulkReveal()" id="bulkRevealBtn">
                            Reveal all passwords
                        </button>
                        <button class="btn btn-outline" onclick="autoDedupe()">
                            Run auto-delete
                        </button>
                    </div>
                </div>

                <div class="table-wrap" id="tableView">
                    <table role="grid">
                        <thead>
                            <tr>
                                <th class="checkbox-cell">
                                    <input type="checkbox" class="custom-checkbox" id="selectAll"
                                        onclick="toggleSelectAll()">
                                </th>
                                <th scope="col">Name</th>
                                <th scope="col">Password</th>
                                <th scope="col" class="action-cell">Action</th>
                            </tr>
                        </thead>
                        <tbody id="itemsTableBody">
                        </tbody>
                    </table>
                </div>

                <div id="dashboardView" class="hidden">
                    <div class="dashboard-grid">
                        <div class="stat-card">
                            <div class="stat-header">
                                <span class="stat-title">Overall Security Grade</span>
                                <div id="healthGrade" class="health-grade grade-a">A</div>
                            </div>
                            <div class="issue-list" id="healthIssues">
                                <!-- Issues list -->
                            </div>
                        </div>

                        <div class="stat-card">
                            <span class="stat-title">Vault Coverage</span>
                            <div class="stat-value" id="statUniqueSites">0</div>
                            <span class="field-sub">Unique base domains extracted</span>
                        </div>

                        <div class="stat-card">
                            <span class="stat-title">Password Hygiene</span>
                            <div class="issue-list" id="hygieneStats">
                                <div class="issue-item">
                                    <div class="indicator red" id="indicatorDuplicate"></div>
                                    <span><strong id="statDuplicatePass">0</strong> <span id="labelDuplicate">Reused
                                            Passwords</span></span>
                                </div>
                                <div class="issue-item">
                                    <div class="indicator yellow" id="indicatorEmpty"></div>
                                    <span><strong id="statEmptyPass">0</strong> <span id="labelEmpty">Missing
                                            Passwords</span></span>
                                </div>
                            </div>
                        </div>

                        <div class="stat-card" style="grid-column: 1 / -1;">
                            <span class="stat-title">Most Reused Passwords</span>
                            <table
                                style="margin-top: 1rem; width: 100%; border-collapse: separate; border-spacing: 0 8px;">
                                <tbody id="statReuseList">
                                    <!-- Top reused passwords -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    <div id="loader" class="loading-overlay">
        <div class="loader-card">
            <div class="spinner"></div>
            <p style="font-weight: 600; letter-spacing: 0.5px;">Processing Data...</p>
        </div>
    </div>

    <script>
        let bitwardenData = null;
        let activeTab = 'all';
        let originalFileName = "";
        let hasUnsavedChanges = false;
        let selectedIndices = new Set();
        let showPasswords = new Set();
        let showAllPasswords = false;
        let filterDeletedOnly = false;
        let focusedIdx = -1;
        let visibleIndices = [];
        let dashboardShowIndices = new Set(); // Stores indices (0-4) of revealed passwords
        let currentDashboardReused = [];
        let dashboardStatsDirty = true;
        let undoStack = []; // Stores actions { type: 'toggle'|'bulk', ... }

        // Security: Input Sanitization
        function escapeHtml(unsafe) {
            if (unsafe == null) return "";
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        // Theme Handling
        function initTheme() {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            if (savedTheme === 'light') {
                document.body.classList.add('light-mode');
                document.getElementById('themeToggleIcon').textContent = '‚òÄÔ∏è';
                document.getElementById('themeToggleText').textContent = 'Light Mode';
            }
        }

        function resetApp() {
            if (confirm("Are you sure? This will clear all loaded data.")) {
                bitwardenData = null;
                document.getElementById('fileInput').value = '';
                document.getElementById('app').classList.add('hidden');
                document.getElementById('uploadOverlay').classList.remove('hidden');
                localStorage.removeItem('wip_audit_' + originalFileName + '_' + (bitwardenData ? bitwardenData.items.length : 0));

                // Clear state
                undoStack = [];
                updateUndoUI();
                selectedIndices.clear();
                showPasswords.clear();
                dashboardShowIndices.clear();
            }
        }

        function toggleTheme() {
            // "Last Resort" UX: Show loader to mask the heavy repaint cost
            withLoader(() => {
                return new Promise(resolve => {
                    // Force a layout/paint frame so the loader appears
                    requestAnimationFrame(() => {
                        const isLight = document.body.classList.toggle('light-mode');
                        localStorage.setItem('theme', isLight ? 'light' : 'dark');

                        const icon = document.getElementById('themeToggleIcon');
                        const term = document.getElementById('themeToggleText');

                        icon.textContent = isLight ? '‚òÄÔ∏è' : 'üåô';
                        term.textContent = isLight ? 'Light Mode' : 'Dark Mode';

                        // Allow browser to repaint the new theme while loader is still up
                        requestAnimationFrame(resolve);
                    });
                });
            });
        }

        // Initialize theme immediately
        initTheme();

        const fileInput = document.getElementById('fileInput');
        const uploadOverlay = document.getElementById('uploadOverlay');
        const app = document.getElementById('app');
        const itemsTableBody = document.getElementById('itemsTableBody');
        const sidebarList = document.getElementById('sidebarList');
        const selectionBar = document.getElementById('selectionBar');

        fileInput.addEventListener('change', handleFile);

        document.body.addEventListener('dragover', (e) => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            if (file) handleFile({ target: { files: [file] } });
        });

        // Event Delegation for Table Body
        itemsTableBody.addEventListener('click', (e) => {
            const row = e.target.closest('tr');
            if (!row) return;
            const index = parseInt(row.dataset.index);
            if (isNaN(index)) return;

            // 1. Password Toggle
            if (e.target.closest('.action-toggle-pass')) {
                togglePassword(index);
                return;
            }

            // 2. Delete/Restore Action
            if (e.target.closest('.action-delete')) {
                toggleItem(index);
                return;
            }

            // 3. Selection (Checkbox or Row Click)
            // Note: If clicking the checkbox directly, we prevent propagation?
            // Actually, for custom styled checkbox/row clicks, we just trigger toggleSelect
            // If the user clicked the actual input, it toggles state. toggleSelect handles the logic.
            // To prevent double-toggling if clicking label wrapping input, we trust the handler.
            toggleSelect(index);
        });

        function handleFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            originalFileName = file.name;
            const reader = new FileReader();

            withLoader(() => {
                return new Promise((resolve, reject) => {
                    reader.onload = (event) => {
                        try {
                            bitwardenData = JSON.parse(event.target.result);
                            if (!bitwardenData.items) throw new Error("This doesn't look like a Bitwarden export.");

                            // Keep only Login items (type 1) and ignore cards, identities, etc.
                            bitwardenData.items = bitwardenData.items.filter(item => item.type === 1);

                            // Pre-calculate expensive fields
                            bitwardenData.items.forEach(item => {
                                item._isDeleted = false;
                                item._hostname = getBaseUrl(item); // Store once
                                item._timestamp = item.revisionDate ? new Date(item.revisionDate).getTime() : 0;
                            });

                            if (restoreWorkInProgress()) {
                                hasUnsavedChanges = true;
                            }

                            uploadOverlay.classList.add('hidden');
                            app.classList.remove('hidden');
                            renderSidebar();
                            renderTable();
                            dashboardStatsDirty = true;
                            resolve();
                        } catch (err) {
                            alert("Error: " + err.message);
                            reject(err);
                        }
                    };
                    reader.readAsText(file);
                });
            });
        }

        function getBaseUrl(item) {
            if (item.type !== 1) return "System Info";
            const login = item.login || {};
            if (!login.uris || login.uris.length === 0) return "No Domain";

            try {
                let raw = login.uris[0].uri || "";
                if (!raw.trim()) return "No Domain";
                if (!raw.includes('://')) raw = 'http://' + raw;
                const host = new URL(raw).hostname.replace('www.', '');
                return host || "No Domain";
            } catch { return "Misc URL"; }
        }

        function renderSidebar() {
            const filter = document.getElementById('sidebarSearch').value.toLowerCase();
            const groups = { 'all': 0 };
            bitwardenData.items.forEach(item => {
                if (filterDeletedOnly && !item._isDeleted) return; // Review Mode: Only count deleted

                const url = item._hostname || getBaseUrl(item);
                groups[url] = (groups[url] || 0) + 1;
                groups['all']++;
            });

            const sortedKeys = Object.keys(groups)
                .filter(k => k.toLowerCase().includes(filter))
                .sort((a, b) => {
                    if (a === 'all') return -1;
                    if (b === 'all') return 1;
                    return groups[b] - groups[a];
                });

            sidebarList.innerHTML = `
                <div class="nav-item ${activeTab === 'dashboard' ? 'active' : ''}" onclick="setTab('dashboard')" 
                     style="margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 1rem;">
                    <span>üõ°Ô∏è Health Report</span>
                </div>
            ` + sortedKeys.map(key => `
                <div class="nav-item ${activeTab === key ? 'active' : ''}" onclick="setTab(this.dataset.key)" data-key="${escapeHtml(key)}" title="${escapeHtml(key)}">
                    <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; margin-right: 8px;">
                        ${key === 'all' ? 'All Items' : escapeHtml(key)}
                    </span>
                    <span class="count">${groups[key]}</span>
                </div>
            `).join('');
        }

        function setTab(key) {
            activeTab = key;
            const isDashboard = key === 'dashboard';

            document.getElementById('tabTitle').textContent = isDashboard ? 'Vault Health Report' : (key === 'all' ? 'Everything' : key);
            document.getElementById('tableView').classList.toggle('hidden', isDashboard);
            document.querySelector('.toolbar').classList.toggle('hidden', isDashboard);
            document.getElementById('dashboardView').classList.toggle('hidden', !isDashboard);

            selectedIndices.clear();
            renderSidebar();

            if (isDashboard) {
                // Only clear if we are actually switching TO dashboard for the first time
                // But honestly, we want to persist state if just switching back and forth?
                // For now, let's keep it clean
                dashboardShowIndices.clear();
                renderDashboard();
            } else {
                renderTable();
            }
        }

        function renderTable() {
            // Update Headers for Review Mode
            const reasonHeaderHtml = filterDeletedOnly ? '<th scope="col" style="width: 20%;">Reason</th>' : '';
            const headerRow = document.querySelector('thead tr');
            headerRow.innerHTML = `
                <th class="checkbox-cell">
                    <input type="checkbox" class="custom-checkbox" id="selectAll" onclick="toggleSelectAll()">
                </th>
                <th scope="col">Name</th>
                ${reasonHeaderHtml}
                <th scope="col">Password</th>
                <th scope="col" class="action-cell">Action</th>
            `;

            const filtered = bitwardenData.items.map((item, index) => ({ item, index }))
                .filter(entry => activeTab === 'all' || entry.item._hostname === activeTab)
                .filter(entry => !filterDeletedOnly || entry.item._isDeleted); // Review Mode Filter

            visibleIndices = filtered.map(f => f.index);

            const rowsHtml = filtered.map(({ item, index }) => {
                const login = item.login || {};
                const name = escapeHtml(item.name || 'Unnamed');
                const username = escapeHtml(login.username || 'No username');
                const usernameRaw = escapeHtml(login.username || '');
                const passwordRaw = login.password ? escapeHtml(login.password) : '';

                const isRevealed = showAllPasswords !== showPasswords.has(index);
                const isSelected = selectedIndices.has(index);
                const isDeleted = item._isDeleted;
                const isFocused = index === focusedIdx;
                const deleteReason = escapeHtml(item._deleteReason || 'Manual Delete');

                const reasonCell = filterDeletedOnly
                    ? `<td><span class="reason-badge">${deleteReason}</span></td>`
                    : '';

                return `
                    <tr id="row-${index}" data-index="${index}" class="${isDeleted ? 'deleted' : ''} ${isSelected ? 'selected' : ''} ${isFocused ? 'focused' : ''}">
                        <td class="checkbox-cell">
                            <input type="checkbox" class="custom-checkbox" ${isSelected ? 'checked' : ''}>
                        </td>
                        <td>
                            <div class="field-box" style="gap: 2px;">
                                <div class="field-value" title="${name}" style="font-weight: 600; color: var(--text-heading); font-size: 0.95rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    ${name}
                                </div>
                                <div class="field-sub" title="${usernameRaw}" style="font-size: 0.85rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    ${username}
                                </div>
                            </div>
                        </td>
                        ${reasonCell}
                        <td>
                            <div class="field-box">
                                <div class="password-container" style="display:flex; justify-content:space-between; align-items:center;">
                                    <div class="password-val" title="${isRevealed ? passwordRaw : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'}"
                                         style="flex:1; margin-right:8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; ${!login.password ? 'color:var(--danger); font-style:italic;' : ''}">
                                        ${login.password ? (isRevealed ? passwordRaw : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') : 'Empty'}
                                    </div>
                                    <button class="btn btn-outline action-toggle-pass" style="padding:2px 6px; font-size:10px; flex-shrink: 0;">
                                        ${isRevealed ? 'Hide' : 'Show'}
                                    </button>
                                </div>
                            </div>
                        </td>
                        <td class="action-cell">
                            <button class="btn ${isDeleted ? 'btn-outline' : 'btn-danger'} action-delete" 
                                    style="min-width: 80px; justify-content: center;">
                                ${isDeleted ? 'Restore' : 'Delete'}
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');

            itemsTableBody.innerHTML = rowsHtml;
            updateStats();
            updateSelectionBar();

            if (focusedIdx === -1 && visibleIndices.length > 0) {
                moveFocus(0);
            }
        }

        function pluralize(count, singular, plural = singular + 's') {
            return `${count} ${count === 1 ? singular : plural}`;
        }

        function renderDashboard() {
            console.log('renderDashboard: dirty=', dashboardStatsDirty);
            if (!dashboardStatsDirty) return;

            const items = bitwardenData.items;
            const passReuse = {};
            let emptyPassCount = 0;
            const domains = new Set();

            items.forEach(item => {
                if (item._isDeleted) return;
                const login = item.login || {};
                const pass = login.password;
                const dom = item._hostname || getBaseUrl(item);

                if (dom !== "Misc URL") domains.add(dom);
                if (!pass) emptyPassCount++;
                else {
                    passReuse[pass] = (passReuse[pass] || 0) + 1;
                }
            });

            // Stable sort by count, then alphabetical password
            const reusedList = Object.entries(passReuse)
                .filter(([_, count]) => count > 1)
                .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0]))
                .slice(0, 5);

            // Store for toggle access
            currentDashboardReused = reusedList.map(([pass, count]) => ({ pass, count }));

            const totalReuseCount = reusedList.reduce((acc, curr) => acc + curr[1], 0);

            // Update UI Counters
            document.getElementById('statUniqueSites').textContent = domains.size;
            document.getElementById('statDuplicatePass').textContent = totalReuseCount;
            document.getElementById('statEmptyPass').textContent = emptyPassCount;

            // Update Hygiene Indicators/Text
            const dupIndicator = document.getElementById('indicatorDuplicate');
            const emptyIndicator = document.getElementById('indicatorEmpty');
            const dupLabel = document.getElementById('labelDuplicate');
            const emptyLabel = document.getElementById('labelEmpty');

            if (dupIndicator) dupIndicator.className = `indicator ${totalReuseCount > 0 ? 'red' : 'green'}`;
            if (emptyIndicator) emptyIndicator.className = `indicator ${emptyPassCount > 0 ? 'yellow' : 'green'}`;

            if (dupLabel) dupLabel.textContent = totalReuseCount === 1 ? 'Reused Password' : 'Reused Passwords';
            if (emptyLabel) emptyLabel.textContent = emptyPassCount === 1 ? 'Missing Password' : 'Missing Passwords';

            const reuseBody = document.getElementById('statReuseList');

            if (reusedList.length === 0) {
                reuseBody.innerHTML = `<tr><td style="color: var(--success); text-align: center; padding: 2rem;">No reused passwords found! Great job.</td></tr>`;
            } else {
                reuseBody.innerHTML = currentDashboardReused.map((item, i) => {
                    const isRevealed = dashboardShowIndices.has(i);
                    return `
                    <tr id="dashboard-reuse-row-${i}">
                        <td style="padding: 10px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                            <code class="pass-display" style="color: var(--primary-light); font-family: monospace;">${isRevealed ? escapeHtml(item.pass) : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'}</code>
                            <button class="btn btn-outline" style="padding: 2px 8px; font-size: 0.7rem;" onclick="toggleDashboardPassword(${i})">
                                ${isRevealed ? 'Hide' : 'Show'}
                            </button>
                        </td>
                        <td style="padding: 10px; border-bottom: 1px solid var(--border); text-align: right; color: var(--text-muted);">
                            Used on <strong>${item.count}</strong> items
                        </td>
                    </tr>
                `;
                }).join('');
            }

            // Calculate Grade & qualitative feedback
            const healthGrade = document.getElementById('healthGrade');
            const healthIssues = document.getElementById('healthIssues');
            let score = 100;

            if (totalReuseCount > 0) score -= Math.min(40, totalReuseCount * 5);
            if (emptyPassCount > 0) score -= Math.min(30, emptyPassCount * 3);

            let statusText = "";
            let gradeClass = "";
            if (score >= 90) { statusText = "Excellent vault security."; gradeClass = "grade-a"; healthGrade.textContent = 'A'; }
            else if (score >= 70) { statusText = "Good, with some minor vulnerabilities."; gradeClass = "grade-b"; healthGrade.textContent = 'B'; }
            else if (score >= 50) { statusText = "Needs attention. High risk of credential stuffing."; gradeClass = "grade-c"; healthGrade.textContent = 'C'; }
            else { statusText = "Critical safety risks detected."; gradeClass = "grade-f"; healthGrade.textContent = 'F'; }

            healthIssues.innerHTML = `<span style="font-weight: 500; font-size: 0.9rem;">Status: ${statusText}</span>`;
            healthGrade.className = 'health-grade ' + gradeClass;

            dashboardStatsDirty = false;
        }

        function toggleDashboardPassword(i) {
            if (dashboardShowIndices.has(i)) dashboardShowIndices.delete(i);
            else dashboardShowIndices.add(i);

            // Localized DOM update
            const row = document.getElementById(`dashboard-reuse-row-${i}`);
            if (row) {
                const isRevealed = dashboardShowIndices.has(i);
                const item = currentDashboardReused[i];
                if (!item) return;

                const codeEl = row.querySelector('.pass-display');
                const btnEl = row.querySelector('button');

                if (codeEl) codeEl.textContent = isRevealed ? item.pass : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                if (btnEl) btnEl.textContent = isRevealed ? 'Hide' : 'Show';
            }
        }

        function togglePassword(idx) {
            if (showPasswords.has(idx)) showPasswords.delete(idx);
            else showPasswords.add(idx);

            // Localized update for the specific row's password cell
            const row = document.getElementById(`row-${idx}`);
            if (row) {
                const isRevealed = showAllPasswords !== showPasswords.has(idx);
                const login = bitwardenData.items[idx].login || {};
                const text = login.password ? (isRevealed ? login.password : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢') : 'Empty';
                const isEmpty = !login.password;

                const container = row.querySelector('.password-container');
                const pVal = container.querySelector('.password-val');
                const btn = container.querySelector('button');

                if (pVal) {
                    pVal.style.color = isEmpty ? 'var(--danger)' : '';
                    pVal.style.fontStyle = isEmpty ? 'italic' : '';
                    pVal.textContent = text;
                    pVal.title = text;
                }
                if (btn) btn.textContent = isRevealed ? 'Hide' : 'Show';
            }
        }

        function checkTruncation(el) {
            // No longer used, but kept as no-op to avoid potential errors if called elsewhere
        }

        function toggleBulkReveal() {
            showAllPasswords = !showAllPasswords;
            showPasswords.clear(); // Reset individual overrides when switching global mode
            const btn = document.getElementById('bulkRevealBtn');
            btn.textContent = showAllPasswords ? 'Hide all passwords' : 'Reveal all passwords';
            renderTable();
        }

        function toggleReviewMode(checkbox) {
            filterDeletedOnly = checkbox.checked;
            renderSidebar();
            renderTable();
        }

        function toggleSelect(idx) {
            if (selectedIndices.has(idx)) selectedIndices.delete(idx);
            else selectedIndices.add(idx);

            // Localized update to avoid full re-render
            const row = document.getElementById(`row-${idx}`);
            if (row) {
                const isSelected = selectedIndices.has(idx);
                row.classList.toggle('selected', isSelected);
                row.querySelector('input[type="checkbox"]').checked = isSelected;
            }
            updateSelectionBar();
        }

        function clearSelection() {
            selectedIndices.clear();
            document.getElementById('selectAll').checked = false;
            // Re-render to update all checkboxes and row styles
            renderTable();
        }

        function toggleSelectAll() {
            withLoader(() => {
                const visible = bitwardenData.items.map((item, index) => ({ item, index }))
                    .filter(entry => activeTab === 'all' || getBaseUrl(entry.item) === activeTab);

                if (selectedIndices.size === visible.length) selectedIndices.clear();
                else visible.forEach(v => selectedIndices.add(v.index));
                renderTable();
            });
        }

        function updateSelectionBar() {
            const count = selectedIndices.size;
            const visible = count > 0;
            selectionBar.classList.toggle('visible', visible);
            document.getElementById('contentShifter').classList.toggle('shifted', visible);
            document.getElementById('selectionText').textContent = `${count} items selected`;

            if (visible) {
                // Always enable buttons; actions are safe no-ops if not applicable
                // This also improves performance by avoiding iteration over all selected items
                document.getElementById('selectionRestoreBtn').disabled = false;
                document.getElementById('selectionDeleteBtn').disabled = false;
            }
        }

        function updateStats() {
            const items = bitwardenData.items;
            const removed = items.filter(i => i._isDeleted).length;
            document.getElementById('totalCount').textContent = items.length;
            document.getElementById('removedCount').textContent = removed;
        }

        function toggleReviewMode(el) {
            filterDeletedOnly = el.checked;
            renderTable();
            renderSidebar();
        }

        function toggleBulkReveal() {
            showAllPasswords = !showAllPasswords;
            document.getElementById('bulkRevealBtn').textContent = showAllPasswords ? 'Mask all passwords' : 'Reveal all passwords';
            renderTable();
        }

        function toggleItem(idx, isUndo = false) {
            const item = bitwardenData.items[idx];

            if (!isUndo) {
                pushUndo({ type: 'toggle', index: idx });
            }

            item._isDeleted = !item._isDeleted;
            hasUnsavedChanges = true;

            // Individual update to avoid layout thrashing
            const row = document.getElementById(`row-${idx}`);
            if (row) {
                const isDeleted = item._isDeleted;
                row.classList.toggle('deleted', isDeleted);

                const actionBtn = row.querySelector('.action-delete');
                if (actionBtn) {
                    actionBtn.textContent = isDeleted ? 'Restore' : 'Delete';
                    actionBtn.className = `btn ${isDeleted ? 'btn-outline' : 'btn-danger'} action-delete`;
                }
            }

            updateStats();
            updateSelectionBar();
            renderSidebar();
            saveWorkInProgress();
            dashboardStatsDirty = true;
        }

        function pushUndo(action) {
            undoStack.push(action);
            if (undoStack.length > 50) undoStack.shift(); // Limit stack size
            updateUndoUI();
        }

        function undoLastAction() {
            const action = undoStack.pop();
            if (!action) return;

            if (action.type === 'toggle') {
                toggleItem(action.index, true);
            } else if (action.type === 'bulk') {
                withLoader(() => {
                    action.indices.forEach(idx => {
                        bitwardenData.items[idx]._isDeleted = action.previousState;
                        if (!action.previousState) {
                            delete bitwardenData.items[idx]._deleteReason;
                        }
                    });
                    hasUnsavedChanges = true;
                    // Full re-render needed for bulk
                    renderTable();
                    updateStats();
                    renderSidebar();
                    saveWorkInProgress();
                    dashboardStatsDirty = true;
                });
            }
            updateUndoUI();
        }

        function updateUndoUI() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                btn.disabled = undoStack.length === 0;
                btn.style.opacity = undoStack.length === 0 ? 0.5 : 1;
            }
        }

        function bulkAction(shouldScrub) {
            withLoader(() => {
                // Save state before changing
                pushUndo({
                    type: 'bulk',
                    indices: Array.from(selectedIndices),
                    previousState: !shouldScrub // If we are scrubbing (true), previous was false
                });

                selectedIndices.forEach(idx => { bitwardenData.items[idx]._isDeleted = shouldScrub; });
                hasUnsavedChanges = true;
                clearSelection();
                saveWorkInProgress();
                dashboardStatsDirty = true;
            });
        }

        function autoDedupe() {
            const mode = document.getElementById('dedupeMode').value;
            const masters = new Map(); // key -> masterItem
            let count = 0;
            let autoDeletedIndices = [];

            // Sort by revisionDate (descending) to prioritize keeping the newest entries
            // If date is missing, fallback to original order
            const itemsToProcess = [...bitwardenData.items]
                .map((item, originalIndex) => ({ item, originalIndex }))
                .sort((a, b) => b.item._timestamp - a.item._timestamp);

            itemsToProcess.forEach(({ item, originalIndex }) => {
                if (item._isDeleted) return;

                const login = item.login || {};
                const user = (login.username || "").trim();
                const pass = (login.password || "").trim();
                const isUserEmpty = user === "";
                const isPassEmpty = pass === "";

                // Scrubbing modes: Target items with missing data
                if (mode === 'incomplete') {
                    if (isUserEmpty || isPassEmpty) {
                        item._isDeleted = true;
                        item._deleteReason = "Scrub: Incomplete";
                        count++;
                        autoDeletedIndices.push(originalIndex);
                    }
                    return;
                }

                if (mode === 'incomplete_both') {
                    if (isUserEmpty && isPassEmpty) {
                        item._isDeleted = true;
                        item._deleteReason = "Scrub: Empty User & Pass";
                        count++;
                        autoDeletedIndices.push(originalIndex);
                    }
                    return;
                }

                // Deduplication modes: Only for Login items (Type 1)
                if (item.type !== 1) return;

                const name = (item.name || "").trim().toLowerCase();
                const fullUri = (login.uris && login.uris.length > 0) ? (login.uris[0].uri || "").trim().toLowerCase() : "none";
                const domain = (item._hostname || getBaseUrl(item)).toLowerCase();
                const userLower = user.toLowerCase();

                let key;
                if (mode === 'user') key = userLower;
                else if (mode === 'user_pass') key = `${userLower}|${pass}`;
                else if (mode === 'name_all') key = `${name}|${userLower}|${pass}`;
                else if (mode === 'url_all') key = `${fullUri}|${userLower}|${pass}`;
                else key = `${domain}|${userLower}|${pass}`; // domain_all (default)

                if (masters.has(key)) {
                    const master = masters.get(key);
                    item._isDeleted = true;
                    item._deleteReason = "Duplicate: " + document.querySelector(`#dedupeMode option[value="${mode}"]`).text;
                    count++;
                    autoDeletedIndices.push(originalIndex);

                    // Smart Merge: Copy unique URIs to the master entry
                    if (login.uris && master.login.uris) {
                        const masterUris = new Set(master.login.uris.map(u => (u.uri || "").trim().toLowerCase()));
                        login.uris.forEach(u => {
                            const normalized = (u.uri || "").trim().toLowerCase();
                            if (normalized && !masterUris.has(normalized)) {
                                master.login.uris.push(u);
                                masterUris.add(normalized);
                            }
                        });
                    }
                } else {
                    masters.set(key, item);
                }
            });

            if (autoDeletedIndices.length > 0) {
                pushUndo({
                    type: 'bulk',
                    indices: autoDeletedIndices,
                    previousState: false // They were active (false), so undoing restores them to active
                });
            }

            hasUnsavedChanges = true;
            renderTable();
            renderSidebar();
            saveWorkInProgress();
            dashboardStatsDirty = true;
            alert(`Auto-delete complete. Marked ${count} potential duplicates for removal.`);
        }

        async function withLoader(callback) {
            const loader = document.getElementById('loader');
            const startTime = Date.now();

            loader.classList.add('active');

            // Ensure the browser has a chance to paint the loader
            await new Promise(r => requestAnimationFrame(() => {
                requestAnimationFrame(() => r());
            }));

            try {
                await callback();
            } finally {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, 500 - elapsed);

                // Ensure loader stays for at least 500ms to prevent flickering
                await new Promise(r => setTimeout(r, remaining));

                loader.classList.remove('active');
            }
        }

        function downloadJSON() {
            const final = bitwardenData.items.filter(i => !i._isDeleted).map(({ _isDeleted, _deleteReason, ...rest }) => rest);
            const blob = new Blob([JSON.stringify({ ...bitwardenData, items: final }, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = originalFileName.replace('.json', '') + '_deduped.json';
            a.click();
            hasUnsavedChanges = false;
            // Clear progress on export
            localStorage.removeItem('wip_audit_' + originalFileName + '_' + bitwardenData.items.length);
        }

        function saveWorkInProgress() {
            if (!bitwardenData) return;
            const key = 'wip_audit_' + originalFileName + '_' + bitwardenData.items.length;
            const states = bitwardenData.items.map(item => ({
                deleted: item._isDeleted,
                reason: item._deleteReason || ""
            }));
            localStorage.setItem(key, JSON.stringify(states));
        }

        function restoreWorkInProgress() {
            const key = 'wip_audit_' + originalFileName + '_' + bitwardenData.items.length;
            const saved = localStorage.getItem(key);
            if (saved) {
                const states = JSON.parse(saved);
                if (states.length === bitwardenData.items.length) {
                    bitwardenData.items.forEach((item, idx) => {
                        item._isDeleted = states[idx].deleted;
                        item._deleteReason = states[idx].reason;
                    });
                    return true;
                }
            }
            return false;
        }

        function resetApp() {
            if (confirm('Are you sure you want to reset? This will clear all data and your current progress.')) {
                localStorage.removeItem('wip_audit_' + originalFileName + '_' + bitwardenData.items.length);
                location.reload();
            }
        }

        window.onbeforeunload = (e) => { if (hasUnsavedChanges) return "You have unsaved changes!"; };

        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            if (activeTab === 'dashboard') return;
            if (['INPUT', 'SELECT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

            if (e.key === 'j') { // Up
                moveFocus(-1);
            } else if (e.key === 'k') { // Down
                moveFocus(1);
            } else if (e.key === 'x') { // Select
                if (focusedIdx !== -1) toggleSelect(focusedIdx);
            } else if (e.key.toLowerCase() === 'd' || e.key === 'Delete') { // Delete/Restore
                if (focusedIdx !== -1) toggleItem(focusedIdx);
                e.preventDefault();
            } else if (e.key === 'Enter') { // Reveal
                if (focusedIdx !== -1) togglePassword(focusedIdx);
            }
        });

        function moveFocus(dir) {
            if (visibleIndices.length === 0) return;

            let currentVisiblePos = visibleIndices.indexOf(focusedIdx);
            let nextPos = currentVisiblePos + dir;

            if (nextPos < 0) nextPos = 0;
            if (nextPos >= visibleIndices.length) nextPos = visibleIndices.length - 1;

            const nextIdx = visibleIndices[nextPos];

            if (focusedIdx !== -1) {
                const oldRow = document.getElementById(`row-${focusedIdx}`);
                if (oldRow) oldRow.classList.remove('focused');
            }

            focusedIdx = nextIdx;
            const newRow = document.getElementById(`row-${focusedIdx}`);
            if (newRow) {
                newRow.classList.add('focused');
                newRow.scrollIntoView({ block: 'nearest', behavior: dir === 0 ? 'auto' : 'smooth' });
            }
        }
    </script>
</body>

</html>